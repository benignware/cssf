<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: eval/eval.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: eval/eval.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const csstree = require('css-tree');
const { add, subtract, divide, multiply } = require('..');
const { parse, stringify, unit } = require('../utils');

const min = (...values) => {
  const u = values.map((value) => unit(value)).filter((u) => u &amp;&amp; u !== '%')[0];
  const f = String(Math.min(...values.map((value) => parseFloat(value))));

  return f + (u || '');
};

const max = (...values) => {
  const u =
    values.map((value) => unit(value)).filter((u) => u &amp;&amp; u !== '%')[0] || '';
  const v = values.map((value) => parseFloat(value));
  const f = String(Math.max(...v));

  return u ? f + u : f;
};

const clamp = (min, value, max) => max(min, min(value, max));

const round = (value, digits = 0) => {
  const u = unit(value);
  const f = parseFloat(value);
  const r = Number(f.toFixed(digits));

  return u ? `${r}${u}` : r;
};

const _var = function (name, value) {
  return this.context.get(name.replace(/^--/, '')) || value;
};

const nameTransformer =
  (options = {}) =>
  (ast) => {
    csstree.walk(ast, {
      leave(node) {
        if (['Function'].includes(node.type)) {
          node.name = (options.functions || {})[node.name] || node.name;
        }
      },
    });

    return ast;
  };

const literalTransformer = () => (ast) => {
  csstree.walk(ast, {
    leave(node) {
      let value;

      if (['Identifier'].includes(node.type)) {
        value = node.name;
      }

      if (['Percentage'].includes(node.type)) {
        value = node.value + '%';
      }

      if (node.unit) {
        value = node.value + node.unit;
      }

      if (typeof value !== 'undefined') {
        node.type = 'String';
        node.value = `'${value}'`;
      }
    },
  });

  return ast;
};

const operatorTransformer =
  (options = {}) =>
  (ast) => {
    const valueTypes = [
      'Number',
      'Dimension',
      'Function',
      'Parentheses',
      'String',
      'Percentage',
    ];

    [
      ['*', '/'],
      ['+', '-'],
    ].map((operators) => {
      csstree.walk(ast, {
        enter(node, item, list) {
          if (node.type === 'Operator' &amp;&amp; operators.includes(node.value)) {
            const operator = node.value;
            const children = list.copy();

            children.clear();

            let prev = item.prev;

            while (prev.data.type === 'WhiteSpace') {
              const p = prev;

              prev = prev.prev;

              list.remove(p);
            }

            list.prevUntil(prev, (data, item) => {
              if (!valueTypes.includes(data.type)) {
                return true;
              }

              children.prependData(data);
              list.remove(item);
            });

            children.appendData({
              type: 'Operator',
              value: ',',
            });

            children.appendData({
              type: 'WhiteSpace',
              value: ' ',
            });

            let next = item.next;

            while (next.data.type === 'WhiteSpace') {
              const n = next;

              next = next.next;

              list.remove(n);
            }

            list.nextUntil(next, (data, item) => {
              if (!valueTypes.includes(data.type)) {
                return true;
              }

              children.appendData(data);
              list.remove(item);
            });

            list.insertData(
              {
                type: 'Function',
                name: Object.assign(
                  {
                    '+': 'add',
                    '-': 'subtract',
                    '*': 'multiply',
                    '/': 'divide',
                  },
                  options.operators
                )[operator],
                children,
              },
              item.next
            );

            list.remove(item);
          }
        },
      });
    });

    return ast;
  };

const transformers = [
  literalTransformer(),
  operatorTransformer(),
  nameTransformer({
    functions: {
      var: '_var',
    },
  }),
];

const functions = Object.assign(
  {
    add,
    subtract,
    multiply,
    divide,
    min,
    max,
    clamp,
    round,
    _var,
  },
  Object.fromEntries(
    ['hsl', 'hsla', 'rgb', 'rgba'].map((name) => [
      name,
      function (...args) {
        return `${name}(${args.join(', ')})`;
      },
    ])
  ),
  {
    calc(expression) {
      return expression;
    },
  }
);

/**
 * Utility fucntion that evaluates a css expression.
 * @alias eval
 * @param {string} A css expression
 * @param {object} context An object that is transformed into css variables to be evaluated
 * @returns {(string|number)} Either a css expression or a number
 */
function evaluate(input, context = {}) {
  if (!isNaN(Number(input))) {
    return Number(input);
  }

  let ast;

  try {
    ast = parse(input);
  } catch (e) {
    console.error(e);
    console.log(input);
    return;
  }

  input = String(input);
  input = stringify(
    (transformers || []).reduce(
      (ast, transformer) => transformer.call(this, ast),
      ast
    )
  );

  const f = new Function(
    '__context__',
    ...Object.keys(functions),
    `
  this.context = new Map();

  for (x in __context__) {
    this.context.set(x, __context__[x]);
  }

  return ${input};
`
  );

  const result = f(context, ...Object.values(functions));

  if (!isNaN(Number(result))) {
    return Number(result);
  }

  return result;
}

module.exports = evaluate;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#abs">abs</a></li><li><a href="global.html#add">add</a></li><li><a href="global.html#alpha">alpha</a></li><li><a href="global.html#and">and</a></li><li><a href="global.html#blue">blue</a></li><li><a href="global.html#brightness">brightness</a></li><li><a href="global.html#calc">calc</a></li><li><a href="global.html#darken">darken</a></li><li><a href="global.html#divide">divide</a></li><li><a href="global.html#eq">eq</a></li><li><a href="global.html#eval">eval</a></li><li><a href="global.html#floor">floor</a></li><li><a href="global.html#green">green</a></li><li><a href="global.html#gt">gt</a></li><li><a href="global.html#gte">gte</a></li><li><a href="global.html#hsla">hsla</a></li><li><a href="global.html#hue">hue</a></li><li><a href="global.html#ifelse">ifelse</a></li><li><a href="global.html#lightness">lightness</a></li><li><a href="global.html#lt">lt</a></li><li><a href="global.html#lte">lte</a></li><li><a href="global.html#luminance">luminance</a></li><li><a href="global.html#mix">mix</a></li><li><a href="global.html#mod">mod</a></li><li><a href="global.html#multiply">multiply</a></li><li><a href="global.html#not">not</a></li><li><a href="global.html#or">or</a></li><li><a href="global.html#pow">pow</a></li><li><a href="global.html#red">red</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#rgba">rgba</a></li><li><a href="global.html#round">round</a></li><li><a href="global.html#saturation">saturation</a></li><li><a href="global.html#subtract">subtract</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Sat Jan 29 2022 17:07:18 GMT+0100 (Mitteleurop√§ische Normalzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
